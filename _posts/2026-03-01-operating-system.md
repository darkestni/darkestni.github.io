---
title: 操作系统
date: 2026-03-01 00:00:00 +0800
categories: [操作系统]
tags: [课程笔记，Linux, 系统编程]
description: 操作系统课程学习笔记和资料
---

## 课程资料

| 讲次 | 主题 | PDF |
|------|------|-----|
| L01 | 操作系统简介 | [下载](/assets/os/L01%20Intro%20to%20OS.pdf) |
| L02 | OS 基础 | [下载](/assets/os/L02%20OS%20Basics.pdf) |
| L03 | 进程 | [下载](/assets/os/L03%20Processes.pdf) |
| L04 | CPU 调度 | [下载](/assets/os/L04%20CPU%20Scheduling.pdf) |
| L05 | 同步 | [下载](/assets/os/L05%20Synchronization.pdf) |
| L06 | 地址转换 | [下载](/assets/os/L06%20Address%20Translation.pdf) |
| L07 | 分页 | [下载](/assets/os/L07%20Paging.pdf) |
| L08 | 按需分页 | [下载](/assets/os/L08%20Demand%20Paging.pdf) |
| L09 | Linux 内存管理 | [下载](/assets/os/L09%20Linux%20Memory%20Management.pdf) |
| L10 | I/O | [下载](/assets/os/L10%20IO.pdf) |
| L11 | 存储 | [下载](/assets/os/L11%20Storage.pdf) |
| L12 | 文件系统 | [下载](/assets/os/L12%20FileSys.pdf) |
| L13 | 死锁 | [下载](/assets/os/L13%20Deadlock.pdf) |

> 实验环境搭建：[Windows 指南](/assets/os/实验环境搭建（Windows）(1).pdf)

---

## L01-L02: 操作系统基础

### 什么是操作系统

**定义**：操作系统是位于硬件和应用软件之间的系统软件，作为资源管理器和服务提供者。

```
┌─────────────────────────────────┐
│         应用程序                 │
├─────────────────────────────────┤
│         操作系统                 │  ← 资源管理器 + 服务提供者
├─────────────────────────────────┤
│         计算机硬件               │
└─────────────────────────────────┘
```

### 操作系统功能

1. **进程管理**：创建、调度、终止进程
2. **内存管理**：分配和回收内存
3. **文件系统**：文件存储和组织
4. **设备管理**：I/O 设备控制
5. **用户接口**：命令行、GUI

### 操作系统的两种视角

| 视角 | 关注点 |
|------|--------|
| **用户视角** | 易用性、功能、性能 |
| **系统视角** | 资源分配、效率、公平性 |

### 计算机体系结构回顾

- **冯·诺依曼架构**：存储程序概念，指令和数据存储在同一内存中
- **哈佛架构**：指令和数据存储在不同内存中

```
CPU 组成：
├── ALU (算术逻辑单元)
├── CU (控制单元)
├── 寄存器组
└── Cache (高速缓存)
```

### 中断机制

**中断**是操作系统事件驱动的基础：

```
程序执行 → 中断发生 → 保存现场 → 中断处理 → 恢复现场 → 继续执行
```

**中断类型**：
- **硬件中断**：I/O 设备、定时器
- **软件中断**：系统调用、异常
- **内部中断**：除零错误、缺页异常

### 系统调用

用户程序通过系统调用请求 OS 服务：

| 类型 | 示例 |
|------|------|
| 进程控制 | fork(), exec(), exit(), wait() |
| 文件操作 | open(), read(), write(), close(), stat() |
| 内存管理 | malloc(), free(), brk(), mmap() |
| 设备管理 | ioctl(), read(), write() |
| 进程间通信 | pipe(), shmget(), mmap() |

**系统调用实现机制**（以 x86 为例）：
```
1. 保存用户态上下文
2. 切换到内核栈
3. 执行内核代码
4. 恢复用户态上下文
```

### 内核结构

| 结构 | 优点 | 缺点 | 示例 |
|------|------|------|------|
| **单内核** | 高效、简单 | 难维护、不安全 | Linux, UNIX |
| **微内核** | 模块化、安全 | 性能开销大 | Minix, QNX |
| **混合内核** | 折中方案 | 复杂度较高 | Windows, macOS |

### 性能指标

- **吞吐量**：单位时间内完成的工作量
- **周转时间**：从提交到完成的总时间
- **响应时间**：从提交到首次响应的时间
- **CPU 利用率**：CPU 繁忙时间占比 (40%-90%)
- **公平性**：各进程获得 CPU 时间的公平程度

---

## L03: 进程

### 进程概念

**进程**：正在执行的程序的实例，是系统进行资源分配和调度的基本单位。

### 进程状态（五状态模型）

```
     新建                    终止
      ↓                      ↑
    就绪 ←──→ 运行 ──→ 等待
      ↑         ↓         ↑
      └─────────┴─────────┘
```

| 状态 | 说明 | 触发事件 |
|------|------|----------|
| **新建** | 进程正在创建 | 用户登录、程序启动 |
| **就绪** | 等待 CPU 分配 | 获得 I/O、时间片到 |
| **运行** | 正在执行指令 | 获得 CPU |
| **等待** | 等待某事件完成 | 请求 I/O、等待信号 |
| **终止** | 进程结束 | 正常退出、异常终止 |

### 进程控制块 (PCB)

Linux 中为 `task_struct` 结构：

```c
struct task_struct {
    pid_t pid;                    // 进程 ID
    enum state state;             // 进程状态
    unsigned long stack;          // 栈指针
    mm_struct *mm;                // 内存管理信息
    struct files_struct *files;   // 文件描述符表
    struct sched_info sched;      // 调度信息
};
```

**PCB 包含**：PID、状态、PC、寄存器、页表、会计信息、I/O 状态

### 进程操作

| 操作 | 系统调用 | 说明 |
|------|----------|------|
| 创建 | `fork()` | 创建子进程，复制父进程地址空间 |
| 执行 | `exec()` | 用新程序替换当前进程映像 |
| 等待 | `wait()` | 等待子进程终止 |
| 终止 | `exit()` | 释放资源，终止进程 |

**fork() 示例**：
```c
pid_t pid = fork();
if (pid == 0) {
    // 子进程
} else if (pid > 0) {
    // 父进程
}
```

### 进程间通信 (IPC)

| IPC 方式 | 特点 | 适用场景 |
|----------|------|----------|
| **管道** | 半双工，父子进程间 | 简单数据流 |
| **命名管道** | 全双工，任意进程 | 不相关进程 |
| **消息队列** | 消息格式，可分类 | 结构化数据 |
| **共享内存** | 最高效，需同步 | 大数据量 |
| **信号量** | 计数器，用于同步 | 进程同步 |
| **信号** | 异步通知 | 事件通知 |
| **套接字** | 网络通信 | 跨主机通信 |

### 进程 vs 线程

| 特性 | 进程 | 线程 |
|------|------|------|
| **地址空间** | 独立 | 共享进程地址空间 |
| **通信** | 需要 IPC | 直接共享内存 |
| **创建开销** | 大 | 小 |
| **切换开销** | 大（TLB 刷新） | 小（仅寄存器） |
| **健壮性** | 高 | 低 |

### 线程模型

| 模型 | 优点 | 缺点 |
|------|------|------|
| **用户级线程** | 切换快，可自定义调度 | 阻塞系统调用会阻塞整个进程 |
| **内核级线程** | 可并行执行 | 切换需要内核介入 |
| **混合模型** | 结合两者优点 | 实现复杂 |

---

## L04: CPU 调度

### 调度层次

| 层次 | 频率 | 功能 |
|------|------|------|
| **长程调度** | 低 | 决定哪些进程进入系统（作业调度） |
| **中程调度** | 中 | 决定哪些进程在内存中（交换） |
| **短程调度** | 高 | 决定哪个进程获得 CPU（CPU 调度） |

### 调度时机

**抢占式调度**：新进程到达、时间片用完、更高优先级就绪
**非抢占式调度**：进程终止、进程等待 I/O

### 调度算法

#### 1. FCFS (先来先服务)

```
进程  到达时间  burst 时间
P1      0         24
P2      0          3
P3      0          3

Gantt: P1 ━━━━━━━━━━ P2 ━━ P3 ━━
      0           24   27   30
平均等待时间 = (0+24+27)/3 = 17
```

- 优点：简单公平
- 缺点：护航效应

#### 2. SJF (短作业优先)

```
进程  到达时间  burst 时间
P1      0          6
P2      0          8
P3      0          7
P4      0          3

Gantt: P4 ━━ P1 ━━━━━━ P3 ━━━━━━━ P2 ━━━━━━━━
      0   3      9        16       24
平均等待时间 = (3+0+9+16)/4 = 7  ← 最优
```

- 优点：平均等待时间最短
- 缺点：需要预知执行时间、可能饥饿

#### 3. Round Robin (时间片轮转)

```
时间片 = 4
进程  到达时间  burst 时间
P1      0         24
P2      0          3
P3      0          3

Gantt: P1 ━━━━ P2 ━━ P3 ━━ P1 ━━━━ P1 ━━━━ P1 ━━━━ P1 ━━
      0    4    7   10   14   18   22   26   30
平均等待时间 = (6+4+7)/3 = 5.67
```

- 优点：响应时间短、公平
- 缺点：时间片选择困难
- 典型时间片：10-100ms

#### 4. 优先级调度

- 优点：重要任务优先
- 缺点：低优先级可能饥饿
- 解决：老化技术（随时间增加优先级）

#### 5. 多级队列调度

```
         新进程
           ↓
    ┌──────┴──────┐
    ↓             ↓
前台队列 (RR)   后台队列 (FCFS)
```

#### 6. 多级反馈队列

```
队列 0 (RR, q=8ms)
   ↓
队列 1 (RR, q=16ms)
   ↓
队列 2 (FCFS)
```

- CPU 密集型 → 降级
- I/O 密集型 → 保持高级

### 算法对比

| 算法 | 优点 | 缺点 |
|------|------|------|
| FCFS | 简单公平 | 护航效应 |
| SJF | 平均等待时间最短 | 需预知时间 |
| RR | 响应快 | 时间片选择困难 |
| 优先级 | 重要任务优先 | 可能饥饿 |
| 多级反馈 | 适应性强 | 实现复杂 |

---

## L05: 进程同步

### 竞态条件

```c
int counter = 0;
counter++;  // LOAD → ADD → STORE
counter--;  // LOAD → SUB → STORE
```

交替执行可能导致 counter 值不正确！

### 临界区问题

**解决方案必须满足**：

| 条件 | 说明 |
|------|------|
| **互斥** | 同一时刻只有一个进程在临界区 |
| **进步** | 无进程在临界区时，想进入可被选中 |
| **有限等待** | 请求后在有限步内被允许进入 |

### Peterson 算法（两进程）

```c
int turn;
bool flag[2];

// 进程 Pi
flag[i] = true;       // 我想进入
turn = j;             // 让你优先
while (flag[j] && turn == j);  // 等待

// 临界区
flag[i] = false;      // 退出
```

### 硬件方案

**Test-and-Set 指令**（原子操作）：
```c
boolean TestAndSet(boolean *target) {
    boolean old = *target;
    *target = true;
    return old;
}
// 使用：while (TestAndSet(&lock)); 临界区; lock=false;
```

### 信号量 (Semaphore)

```c
// P 操作（wait）
void wait(semaphore *S) {
    S->value--;
    if (S->value < 0) block();
}

// V 操作（signal）
void signal(semaphore *S) {
    S->value++;
    if (S->value <= 0) wakeup();
}
```

### 经典同步问题

#### 1. 有界缓冲区

```c
semaphore mutex=1, empty=N, full=0;

// 生产者              // 消费者
wait(empty);          wait(full);
wait(mutex);          wait(mutex);
add item;             remove item;
signal(mutex);        signal(mutex);
signal(full);         signal(empty);
```

#### 2. 读者 - 写者（读者优先）

```c
semaphore mutex=1, db=1;
int readcount=0;

// 读者
wait(mutex); readcount++;
if (readcount==1) wait(db);
signal(mutex); read();
wait(mutex); readcount--;
if (readcount==0) signal(db);
signal(mutex);
```

#### 3. 哲学家就餐

```c
semaphore chopstick[5] = {1,1,1,1,1};
// 哲学家 i: wait(chopstick[i]); wait(chopstick[(i+1)%5]); eat();
```

**解决方案**：限制 4 人、奇偶反向、AND 信号量

---

## L06-L08: 内存管理

### 地址转换

| 地址类型 | 说明 |
|----------|------|
| **逻辑地址** | CPU 生成的地址（虚拟地址） |
| **物理地址** | 内存单元实际看到的地址 |

```
逻辑地址：[页号 | 页内偏移]
          ↓ 页表转换
物理地址：[页框号 | 页内偏移]
```

### 分页机制

- **页**：逻辑内存块（通常 4KB）
- **页框**：物理内存块
- **页表**：页号 → 页框号映射

**页表项结构**：
```
| 页框号 | 有效位 | 修改位 | 保护位 | 引用位 |
```

### TLB（快表）

加速地址转换的专用高速缓存：

```
CPU 生成逻辑地址
    ↓
  [TLB] ← 高速缓存
    ↓ 未命中
  页表 (内存中)
    ↓
 物理地址
```

**有效访问时间** = 命中率 × (TLB 访问时间) + 缺页率 × (页表访问时间 + TLB 访问时间)

### 页面置换算法

| 算法 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **OPT** | 置换最长不用的页面 | 理论最优 | 无法实现（需要未来信息） |
| **FIFO** | 置换最早进入的页面 | 简单 | 可能置换常用页 |
| **LRU** | 置换最近最少使用的页面 | 性能好 | 需要硬件支持 |
| **Clock** | LRU 的近似实现 | 实用高效 | - |

**Belady 异常**：FIFO 算法中，增加页框数反而增加缺页率

### 按需分页

```
进程启动
   ↓
仅加载需要的页
   ↓
缺页中断 → 从磁盘加载页面
   ↓
继续执行
```

**缺页率公式**：
```
有效访问时间 = (1-p) × 内存访问时间 + p × 缺页处理时间
```

其中 p = 缺页率

---

## L09: Linux 内存管理

### 虚拟内存

- 每个进程有独立的虚拟地址空间（32 位系统为 4GB）
- 通过页表映射到物理内存
- 支持按需加载、内存共享

### Linux 地址空间布局（32 位）

```
0xFFFFFFFF  ┌─────────────────┐
            │    内核空间      │ 1GB
0xC0000000  ├─────────────────┤
            │      栈          │ ↓ 增长
            │         ↓        │
            │         ↑        │
            │      堆          │ ↑ 增长
            ├─────────────────┤
            │   共享库         │
            ├─────────────────┤
            │      BSS         │
            │      Data        │
            │      Text        │
0x00000000  └─────────────────┘
```

### 内存分配

**用户态**：
- `malloc()` / `free()`：glibc 管理
- `mmap()`：内存映射文件

**内核态**：
- 伙伴系统：管理物理页框
- SLAB 分配器：缓存常用对象

### 写时复制 (Copy-on-Write)

```c
fork() 时不立即复制内存
  ↓
父子进程共享只读页面
  ↓
任一方写操作 → 缺页中断 → 复制该页
```

---

## L10-L11: I/O 与存储

### I/O 控制方式

| 方式 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **程序轮询** | CPU 不断检查设备状态 | 简单 | CPU 浪费 |
| **中断驱动** | 设备完成后通知 CPU | CPU 利用率高 | 频繁中断开销 |
| **DMA** | 设备直接与内存交换数据 | 高效，CPU 干预少 | 需要 DMA 控制器 |

### I/O 软件层次

```
┌─────────────────────┐
│     用户进程        │
├─────────────────────┤
│   设备无关 I/O 软件   │
├─────────────────────┤
│     设备驱动程序     │
├─────────────────────┤
│     中断处理程序     │
├─────────────────────┤
│       硬件          │
└─────────────────────┘
```

### 存储层次结构

```
CPU 寄存器
    ↓ 最快，最小
L1 Cache
    ↓
L2 Cache
    ↓
L3 Cache
    ↓
   内存 (DRAM)
    ↓
   SSD (Flash)
    ↓
   HDD (磁盘)
    ↓ 最慢，最大
  磁带/网络存储
```

### 磁盘调度算法

| 算法 | 说明 | 特点 |
|------|------|------|
| **FCFS** | 先来先服务 | 公平但寻道时间长 |
| **SSTF** | 最短寻道时间优先 | 寻道时间短，可能饥饿 |
| **SCAN** | 电梯算法 | 双向扫描，公平 |
| **C-SCAN** | 循环扫描 | 单向，响应时间均匀 |

---

## L12: 文件系统

### 文件概念

**文件**：逻辑存储单元，具有名称、属性、内容

**文件属性**：
- 名称、类型、大小
- 位置、保护权限
- 创建时间、访问时间

### 文件操作

```c
open()   // 打开文件
read()   // 读取数据
write()  // 写入数据
seek()   // 定位指针
close()  // 关闭文件
unlink() // 删除文件
```

### 目录结构

| 结构 | 说明 | 优缺点 |
|------|------|--------|
| 单级目录 | 所有文件在同一目录 | 简单，不能重名 |
| 两级目录 | 用户目录 + 文件目录 | 支持重名 |
| 树形目录 | 多级目录结构 | 灵活，广泛应用 |
| 无环图 | 支持链接/共享 | 复杂，可能有悬空引用 |

### Linux 文件系统

```
/           根目录
├── bin/    基本命令
├── boot/   启动文件
├── dev/    设备文件
├── etc/    配置文件
├── home/   用户目录
├── lib/    库文件
├── media/  可移动媒体
├── mnt/    挂载点
├── opt/    可选软件
├── proc/   进程信息（虚拟）
├── root/   root 用户目录
├── tmp/    临时文件
├── usr/    用户程序
└── var/    可变数据
```

### 文件分配方式

| 方式 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **连续** | 文件占用连续块 | 顺序访问快 | 外部碎片 |
| **链接** | 每块指向下块 | 无外部碎片 | 仅支持顺序访问 |
| **索引** | 索引块记录所有块 | 支持随机访问 | 索引块开销 |

### inode

Linux 文件元数据结构：
- 文件大小、所有者
- 权限、时间戳
- 数据块指针（直接、间接）

---

## L13: 死锁

### 死锁条件（必须同时满足）

1. **互斥**：资源不能共享
2. **持有并等待**：持有资源同时请求其他资源
3. **不可抢占**：资源不能强制剥夺
4. **循环等待**：存在循环等待链

### 资源分配图

```
进程：○    资源：□
请求边：○ → □
分配边：□ → ○

存在环 → 可能死锁（多实例资源）
存在环 → 一定死锁（单实例资源）
```

### 死锁处理策略

| 策略 | 方法 |
|------|------|
| **预防** | 破坏四个必要条件之一 |
| **避免** | 银行家算法，动态检测 |
| **检测** | 定期检测资源分配图 |
| **恢复** | 终止进程或抢占资源 |

### 银行家算法

**数据结构**：
- Available: 可用资源向量
- Max: 最大需求矩阵
- Allocation: 已分配矩阵
- Need: 还需矩阵 = Max - Allocation

**安全性算法**：
```
1. Work = Available, Finish[i] = false
2. 找进程 i 满足：Finish[i]=false 且 Need[i] ≤ Work
3. 若找到：Work += Allocation[i], Finish[i]=true，返回 2
4. 若所有 Finish[i]=true → 安全状态
```

### 死锁预防

| 条件 | 预防方法 |
|------|----------|
| 互斥 | 使用可共享资源 |
| 持有并等待 | 申请所有资源后再执行 |
| 不可抢占 | 允许抢占 |
| 循环等待 | 资源编号，按序申请 |

---

## 重点知识点总结

- [x] 进程状态与 PCB
- [x] CPU 调度算法对比
- [x] 进程同步与信号量
- [x] 分页与页面置换
- [x] 死锁条件与银行家算法

## 待补充

- [ ] 课后习题
- [ ] 实验笔记
- [ ] Linux 命令实践

---

## 常用 Linux 命令

### 进程管理

```bash
ps aux           # 查看进程
top              # 动态进程监控
kill -9 PID      # 强制终止进程
nice -n 10 cmd   # 设置优先级
```

### 内存管理

```bash
free -h          # 查看内存使用
vmstat           # 虚拟内存统计
cat /proc/meminfo # 详细内存信息
```

### I/O 与存储

```bash
df -h            # 磁盘空间
du -sh *         # 目录大小
iostat           # I/O 统计
lsblk            # 块设备信息
```
